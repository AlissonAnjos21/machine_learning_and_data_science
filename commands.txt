 pd.read_csv((base de dados)) -> Recebe o caminho (sistema de pastas) de um arquivo csv e lê ele possibilitando, assim, a sua manipulação;

.head() -> Exibe os 5 primeiros valores da base de dados utilizada, esse número pode ser alterado ao se informar um parâmetro;

.tail() -> Exibe os 5 últimos valores da base de dados utilizada, esse número pode ser alterado ao se informar um parâmetro;

.describe() -> Exibe algumas coisas úteis, como número de respostas, médias, desvios padrão, etc;

np.unique(base de dados[coluna]) -> Recebe como parâmetro uma coluna da base de dados e retorna a as diferentes respostas presentes nas mesmas, ou seja, não repete valores iguais. Ao passar-se como parâmetro return_counts=True, ele informa a quantidade de vezes que aquele dado apareceu;

sns.countplot(x=(valor)) -> Recebe como parâmetro um valor para x e assim controi uma gráfico de barras mostrando a quantidade de cada uma das possibilidades desse valor x;

plt.show() -> Exibe o gráfico criado para o usuário através de uma interface gráfica;

plt.hist(x = base de dados[coluna]) -> Recebe um valor de x, com uma coluna da base de dados, criando com ele um gráfico de barras com intervalos;

px.scatter_matrix(base de dados, dimensions=[coluna1, coluna2, etc]) -> Recebe como parâmetros a base de dados e as colunas que serão exibidas e produz um gráfico para cada coluna com os campos tanto na direção vertical quanto na horizontal. Possui como um dos parâmetros opcionais o color, que recebe uma das colunas e, assim, exibe quais itens do gráfico correspondem aos intervalos do item da coluna informada;

.loc[base de dados[coluna] (condição se tiver)] -> Localiza os dados de alguma coluna; podendo ser também aplicado algum filtro;

.drop() -> Recebe como parâmetro o índice de um elemento que cumpre determianda condição, sendo que, os elementos que cumprirem tal condição serão apagados da base de dados;

.index -> Informa o índice de algo;

.sum -> Retorna a soma de determinada coisa. Dependendo de como utilizada, pode retornar quantas vezes algo apareceu;

.mean() -> Informa a média de algo;

.isnull() -> Informa se valores da tabela que são ou não nulos retornando True. Caso seja passado como parâmetro uma base de dados com determinada coluna, ele retorna True para os valores nulos dentro daquela coluna;

.fillna() -> Recebe um valor como parãmetro e preenche os campos com valores nulos. Para que ele consiga alterar o valor da variável da base de dados e salvar o novo valor nela, é necessário informar que o parâmetro inplace=True;

.isin -> Informa True caso o valor ao qual ele esteja acessando exista dentro de um intervalo que foi informado como parâmetro. Na maior parte das vezes usa-se uma lista contendo os valores desejados e informa-se como parâmetro;

.values -> Informa o valor de determinado item, convertendo-o para um numpy array;

.iloc -> Seleciona linhas e colunas do data frame, sendo que, o primeiro parâmetro é relativo as linhas desejadas. Já o segundo parâmetro, é referente às colunas a serem pegadas. Para selecioná-las, é necessário informar os intervalos, de forma semelhante a uma lista/tupla;

.min() -> Seleciona o menor valor de um agrupamento de valores;

.max() -> Seleciona o maior valor de um agrupamento de valores;

(objeto StandardScaler).fit_transform() -> Recebe como parâmetro uma lista de dados e os padroniza;

px.treemap(base de dados, path=[colunas]) -> Recebe a base de dados e a coluna desejada. Assim, criando uma representação retangularcom base nas respostas. Aquelas respostas que aparecem mais ficam maiores, equanto as que aparecem menos ficam proporcionalmente menores. Quando é informado mais de uma coluna, aparecem outras representações retangulares dentro da representação principal (primeira representação), esses sub-retângulos, assim como o retângulo principal, também são proporcionais ao número de ocorrencias;

px.parallel_categories(base de dados, dimensions=[coluna1, coluna2, etc]) -> Recebe como parâmetros a base de dados e as colunas que serão exibidas e gera uma representação gráfica que liga as ocorrencias (valores das colunas) uma com a outra por meio de linhas;

.columns -> Informa as colunas presentes na base de dados;

(objeto LabelEncoder).fit_transform(x[:, indice coluna]) -> Transforma um dado do tipo Categórico em um dado do tipo Numérico;

ColumnTransformer(transformers=[('OneHot', OneHotEncoder(), [lista com os índices das colunas que serão sub-divididas])], remainder='passthrough') -> Recebe uma lista com os valores dos índices que se deseja sub-dividir e os sub-divide, ou seja, para cada diferente opção de valor que uma coluna pode ter, ele cria uma sub-coluna, se o valor da linha corresponder ao da sub-coluna o valor dessa sub-coluna é 1, caso o valor da linha não corresponda ao da sub-coluna, o seu valor é 0. Só é possível ter um valor de 1 por cada linha de sub-coluna de coluna. Além disso, ao final, é necessário informar que o ramainder='passthrough', isso faz com que os índices das colunas da base de dados não selecionados continuem os mesmos. Caso contrário, essas colunas não selecionadas seriam pagadas, permecendo apenas aquelas selecionadas;

(objeto OneHotEncoder).fit_transform(x).toarray() -> Executa o processo citado anteriormente e converte o dado obtido para o formato array;

.toarray() -> Converte algo para o formato de array, tem coisas que não são capazes de serem transformadas em array;

.shape -> Retorna a quantidade de, respectivamente, linhas e colunas de uma base de dados;

(X_treinamento, X_teste, Y_treinamento, Y_teste) = train_test_split(x, y, test_size=(percentual de dados separados para o teste), random_state = (qualquer número (0 por convenção))) -> Separa dados para as variáveis de treinamento e para as variáveis de teste. O text_size é referente ao percentual de dados que você quer separar para o teste, ex: 0.25 = 25%. O random_state é para que após cada execução ele mantenha um valor padrão para os dados. Caso não fosse utilizado, a cada execução os valores seriam diferentes, por isso, é mais fácil utilizar esse atributo, principalmente em momentos de criação/teste. O número que ele recebe pode ser qualquer um, porém, por convenção, usá-se 0.
